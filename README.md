# Engagement Service

Microservicio para el tracking y an√°lisis de engagement de usuarios en la aplicaci√≥n RunInsight.

## üéØ Prop√≥sito

Este microservicio se encarga de recopilar y analizar datos de engagement de los usuarios, incluyendo:
- Tiempo de permanencia en cada vista
- Frecuencia de uso de la aplicaci√≥n
- Patrones de navegaci√≥n
- M√©tricas para entrenar modelos predictivos de churn
- Gesti√≥n centralizada de vistas disponibles
- Integraci√≥n con API Gateway para autenticaci√≥n centralizada

## üèóÔ∏è Arquitectura

El microservicio sigue una arquitectura en capas:

```
src/
‚îú‚îÄ‚îÄ config/          # Configuraciones (DB, etc.)
‚îú‚îÄ‚îÄ controllers/     # Controladores HTTP
‚îú‚îÄ‚îÄ middleware/      # Middleware personalizado (auth, etc.)
‚îú‚îÄ‚îÄ models/          # Modelos de datos
‚îú‚îÄ‚îÄ routes/          # Definici√≥n de rutas
‚îú‚îÄ‚îÄ services/        # L√≥gica de negocio
‚îî‚îÄ‚îÄ app.js          # Punto de entrada
```

## üöÄ Instalaci√≥n

1. **Clonar el repositorio**
```bash
git clone <repository-url>
cd engagement-service
```

2. **Instalar dependencias**
```bash
npm install
```

3. **Configurar variables de entorno**
```bash
cp env.example .env
# Editar .env con tus configuraciones
```

4. **Configurar la base de datos**
```sql
-- Crear tabla de vistas disponibles
CREATE TABLE IF NOT EXISTS views_availabe (
  id SERIAL PRIMARY KEY,
  view_name VARCHAR(255) UNIQUE NOT NULL
);

-- Crear tabla de engagement logs
CREATE TABLE IF NOT EXISTS engagement_logs (
  id SERIAL PRIMARY KEY,
  user_id INTEGER NOT NULL,
  view_id INTEGER NOT NULL REFERENCES views_availabe(id),
  duration_seconds INTEGER NOT NULL,
  viewed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Crear √≠ndices para mejor rendimiento
CREATE INDEX IF NOT EXISTS idx_engagement_logs_user_id ON engagement_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_engagement_logs_viewed_at ON engagement_logs(viewed_at);
CREATE INDEX IF NOT EXISTS idx_views_availabe_name ON views_availabe(view_name);
```

5. **Ejecutar el servicio**
```bash
# Desarrollo
npm run dev

# Producci√≥n
npm start
```

## üìä Endpoints

### Health Check
```
GET /api/engagement-logs/health
```

### Crear Engagement Log
```
POST /api/engagement-logs
Content-Type: application/json
user-id: 123
Authorization: Bearer your-jwt-token

{
  "view_name": "dashboard",
  "duration_seconds": 300,
  "viewed_at": "2024-01-15T10:30:00Z"
}
```

**Nota:** El `user_id` se env√≠a en el header `user-id` (validado previamente por el API Gateway)

### Obtener Engagement Logs por Usuario
```
GET /api/engagement-logs/user/:userId?limit=100&offset=0
```

### Obtener Todos los Engagement Logs
```
GET /api/engagement-logs?limit=100&offset=0
```

### Estad√≠sticas de Engagement por Usuario
```
GET /api/engagement-logs/stats/user/:userId
```

### Estad√≠sticas de Engagement por Vista
```
GET /api/engagement-logs/stats/views
```

### An√°lisis Detallado de Engagement
```
GET /api/engagement-logs/analytics/user/:userId?days=30
```

### Gesti√≥n de Vistas
```
GET /api/engagement-logs/views
POST /api/engagement-logs/views
GET /api/engagement-logs/views/:viewName
```

## üîê Autenticaci√≥n y Autorizaci√≥n

### Headers Requeridos

El microservicio espera que el API Gateway valide la autenticaci√≥n y env√≠e el `user_id` en los headers:

| Header | Descripci√≥n | Ejemplo |
|--------|-------------|---------|
| `user-id` | ID del usuario validado | `user-id: 123` |
| `x-user-id` | Alternativa para user-id | `x-user-id: 123` |
| `Authorization` | Token JWT (opcional) | `Authorization: Bearer token` |

### Flujo de Autenticaci√≥n

1. **Cliente** env√≠a petici√≥n con token JWT
2. **API Gateway** valida el token y extrae `user_id`
3. **API Gateway** reenv√≠a la petici√≥n al microservicio con `user-id` en headers
4. **Microservicio** valida el formato del `user_id` y procesa la petici√≥n

## üóÑÔ∏è Estructura de Base de Datos

### Tabla `views_availabe`
```sql
CREATE TABLE views_availabe (
  id SERIAL PRIMARY KEY,
  view_name VARCHAR(255) UNIQUE NOT NULL
);
```

### Tabla `engagement_logs`
```sql
CREATE TABLE engagement_logs (
  id SERIAL PRIMARY KEY,
  user_id INTEGER NOT NULL,
  view_id INTEGER NOT NULL REFERENCES views_availabe(id),
  duration_seconds INTEGER NOT NULL,
  viewed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### √çndices Optimizados
```sql
CREATE INDEX idx_engagement_logs_user_id ON engagement_logs(user_id);
CREATE INDEX idx_engagement_logs_viewed_at ON engagement_logs(viewed_at);
CREATE INDEX idx_views_availabe_name ON views_availabe(view_name);
```

## üîß Configuraci√≥n

### Variables de Entorno

| Variable | Descripci√≥n | Default |
|----------|-------------|---------|
| `PORT` | Puerto del servidor | `3001` |
| `NODE_ENV` | Entorno de ejecuci√≥n | `development` |
| `DB_HOST` | Host de la base de datos | `localhost` |
| `DB_PORT` | Puerto de la base de datos | `5432` |
| `DB_NAME` | Nombre de la base de datos | `runinsight_db` |
| `DB_USER` | Usuario de la base de datos | `postgres` |
| `DB_PASSWORD` | Contrase√±a de la base de datos | - |
| `ALLOWED_ORIGINS` | Or√≠genes permitidos para CORS | `*` |

### Inicializaci√≥n de Base de Datos

1. **Crear las tablas:**
```sql
-- Crear tabla de vistas disponibles
CREATE TABLE IF NOT EXISTS views_availabe (
  id SERIAL PRIMARY KEY,
  view_name VARCHAR(255) UNIQUE NOT NULL
);

-- Crear tabla de engagement logs
CREATE TABLE IF NOT EXISTS engagement_logs (
  id SERIAL PRIMARY KEY,
  user_id INTEGER NOT NULL,
  view_id INTEGER NOT NULL REFERENCES views_availabe(id),
  duration_seconds INTEGER NOT NULL,
  viewed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Crear √≠ndices para mejor rendimiento
CREATE INDEX IF NOT EXISTS idx_engagement_logs_user_id ON engagement_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_engagement_logs_viewed_at ON engagement_logs(viewed_at);
CREATE INDEX IF NOT EXISTS idx_views_availabe_name ON views_availabe(view_name);
```

2. **Inicializar vistas comunes:**
```bash
# Ejecutar el script de inicializaci√≥n
psql -d runinsight_db -f database/init_views.sql
```

El script `database/init_views.sql` incluye vistas comunes como:
- `dashboard`, `profile`, `training`, `stats`
- `achievements`, `rewards`, `social`, `friends`
- `settings`, `notifications`, `chatbot`
- Y muchas m√°s...

### Configuraci√≥n del API Gateway

Para integrar con el microservicio, el API Gateway debe:

1. **Validar el token JWT** y extraer el `user_id`
2. **Agregar el header** `user-id` a la petici√≥n
3. **Reenviar la petici√≥n** al microservicio

**Ejemplo de configuraci√≥n (Kong):**
```yaml
routes:
  - name: engagement-service
    paths: ["/api/engagement-logs"]
    strip_path: true
    plugins:
      - name: jwt
        config:
          secret: your-jwt-secret
      - name: serverless-functions
        config:
          functions:
            - |
              return function()
                local jwt = require("kong.plugin.jwt")
                local user_id = jwt.get_claim("user_id")
                kong.service.request.set_header("user-id", user_id)
              end
```

## üìà Uso para Modelos Predictivos

### Datos Recolectados

El servicio recolecta los siguientes datos √∫tiles para modelos de churn:

1. **Frecuencia de uso**: N√∫mero de sesiones por d√≠a/semana
2. **Duraci√≥n de sesiones**: Tiempo promedio en la aplicaci√≥n
3. **Patrones de navegaci√≥n**: Qu√© vistas visitan m√°s
4. **Tendencias de engagement**: Si el uso aumenta o disminuye
5. **√öltima actividad**: Cu√°ndo fue la √∫ltima vez que us√≥ la app
6. **Vistas espec√≠ficas**: An√°lisis detallado por cada vista de la aplicaci√≥n

### Ventajas de la Nueva Estructura

- ‚úÖ **Normalizaci√≥n**: Evita duplicaci√≥n de nombres de vistas
- ‚úÖ **Rendimiento**: Consultas m√°s r√°pidas con √≠ndices optimizados
- ‚úÖ **Flexibilidad**: Creaci√≥n autom√°tica de nuevas vistas
- ‚úÖ **Consistencia**: Nombres de vistas estandarizados
- ‚úÖ **Seguridad**: Autenticaci√≥n centralizada en API Gateway
- ‚úÖ **Escalabilidad**: Microservicios sin l√≥gica de autenticaci√≥n duplicada

### Ejemplo de Uso para ML

```javascript
// Obtener datos para entrenar modelo
const analytics = await fetch('/api/engagement-logs/analytics/user/123?days=30');
const userData = analytics.data;

// Features para el modelo:
// - userData.total_sessions (frecuencia)
// - userData.avg_duration (tiempo promedio)
// - userData.engagement_trend (tendencia)
// - userData.daily_engagement (patr√≥n diario)
// - userData.unique_views (diversidad de uso)
```

### Gesti√≥n de Vistas para ML

```javascript
// Obtener todas las vistas disponibles
const views = await fetch('/api/engagement-logs/views');
const availableViews = views.data;

// Verificar si una vista espec√≠fica existe
const viewCheck = await fetch('/api/engagement-logs/views/dashboard');
const viewExists = viewCheck.data.exists;

// Crear nueva vista si es necesario
await fetch('/api/engagement-logs/views', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ view_name: 'new_feature' })
});
```

### Ejemplo con Autenticaci√≥n

```javascript
// El API Gateway maneja la autenticaci√≥n autom√°ticamente
const response = await fetch('/api/engagement-logs', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer your-jwt-token'
    // user-id se agrega autom√°ticamente por el API Gateway
  },
  body: JSON.stringify({
    view_name: 'dashboard',
    duration_seconds: 300
  })
});
```

## üéØ Recomendaciones para Frontend

### Autenticaci√≥n y Headers

El microservicio espera que el `user_id` sea enviado en los headers, validado previamente por el API Gateway:

```javascript
// Headers requeridos (el API Gateway los agrega autom√°ticamente)
const headers = {
  'Content-Type': 'application/json',
  'Authorization': 'Bearer your-jwt-token'
  // user-id se agrega autom√°ticamente por el API Gateway
};
```

### Integraci√≥n con API Gateway

El frontend solo necesita enviar el token JWT. El API Gateway se encarga de:

1. **Validar el token** JWT
2. **Extraer el user_id** del token
3. **Agregar el header** `user-id` a la petici√≥n
4. **Reenviar** al microservicio

### Tracking de Tiempo en Pantalla

```javascript
class EngagementTracker {
  constructor() {
    this.startTime = Date.now();
    this.currentView = null;
    this.isActive = true;
  }

  // Iniciar tracking de una vista
  startTracking(viewName) {
    this.currentView = viewName;
    this.startTime = Date.now();
    this.isActive = true;
  }

  // Detener tracking y enviar datos
  async stopTracking() {
    if (!this.currentView || !this.isActive) return;

    const duration = Math.floor((Date.now() - this.startTime) / 1000);
    
    await this.sendEngagementLog({
      user_id: getCurrentUserId(),
      view_name: this.currentView,
      duration_seconds: duration,
      viewed_at: new Date().toISOString()
    });

    this.currentView = null;
    this.isActive = false;
  }

  // Enviar datos al microservicio
  async sendEngagementLog(data) {
    try {
      await fetch('/api/engagement-logs', {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.getAuthToken()}` // Token JWT
          // user-id se agrega autom√°ticamente por el API Gateway
        },
        body: JSON.stringify({
          view_name: data.view_name,
          duration_seconds: data.duration_seconds,
          viewed_at: data.viewed_at
          // user_id NO va en el body
        })
      });
    } catch (error) {
      console.error('Error sending engagement log:', error);
    }
  }

  // Obtener vistas disponibles
  async getAvailableViews() {
    try {
      const response = await fetch(`${this.apiUrl}/views`);
      return await response.json();
    } catch (error) {
      console.error('EngagementTracker: Error fetching views:', error);
      return null;
    }
  }

  // Verificar si una vista existe
  async checkViewExists(viewName) {
    try {
      const response = await fetch(`${this.apiUrl}/views/${encodeURIComponent(viewName)}`);
      return await response.json();
    } catch (error) {
      console.error('EngagementTracker: Error checking view:', error);
      return null;
    }
  }
}

// Uso en React/Vue/Angular
const tracker = new EngagementTracker();

// Al entrar a una vista
onViewEnter('dashboard') {
  tracker.startTracking('dashboard');
}

// Al salir de una vista
onViewLeave() {
  tracker.stopTracking();
}

// Al cambiar de pesta√±a o cerrar la app
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    tracker.stopTracking();
  }
});
```

### Eventos Recomendados para Trackear

1. **Cambio de vista/p√°gina**
2. **Interacciones importantes** (botones, formularios)
3. **Tiempo de inactividad**
4. **Cierre de pesta√±a/aplicaci√≥n**
5. **Scroll y navegaci√≥n**

### Gesti√≥n Autom√°tica de Vistas

El microservicio maneja autom√°ticamente la creaci√≥n de nuevas vistas:

```javascript
// El frontend solo necesita enviar el view_name
// El backend se encarga de crear la vista si no existe
await tracker.sendEngagementLog({
  view_name: 'new_feature',  // Se crea autom√°ticamente si no existe
  duration_seconds: 300,
  viewed_at: new Date().toISOString()
  // user_id se maneja autom√°ticamente por el API Gateway
});
```

### Middleware de Autenticaci√≥n

El microservicio incluye middleware para validar el `user_id`:

```javascript
// src/middleware/auth.js
const validateUserId = (req, res, next) => {
  const userId = req.headers['user-id'] || req.headers['x-user-id'];
  
  if (!userId || !Number.isInteger(Number(userId)) || Number(userId) <= 0) {
    return res.status(401).json({
      success: false,
      message: 'Invalid User ID'
    });
  }
  
  req.userId = parseInt(userId);
  next();
};
```

### Vistas Predefinidas

El sistema incluye vistas comunes para aplicaciones de fitness:
- **Dashboard**: P√°gina principal
- **Training**: Gesti√≥n de entrenamientos
- **Stats**: Estad√≠sticas del usuario
- **Profile**: Perfil del usuario
- **Social**: Funciones sociales
- **Settings**: Configuraciones
- Y muchas m√°s...

## üß™ Testing

```bash
# Ejecutar tests
npm test

# Tests en modo watch
npm run test:watch

# Tests espec√≠ficos de autenticaci√≥n
npm test -- tests/auth.test.js

# Tests del servicio
npm test -- tests/EngagementLogService.test.js
```

### Cobertura de Tests

- ‚úÖ **Tests unitarios** para todos los servicios
- ‚úÖ **Tests de middleware** de autenticaci√≥n
- ‚úÖ **Tests de validaci√≥n** de headers
- ‚úÖ **Tests de casos de error** y edge cases
- ‚úÖ **Mocks** para dependencias externas

## üìù Logs

El servicio utiliza Morgan para logging HTTP y Winston para logs de aplicaci√≥n.

### Niveles de Log
- `error`: Errores cr√≠ticos
- `warn`: Advertencias
- `info`: Informaci√≥n general
- `debug`: Informaci√≥n de debugging

## üîí Seguridad

- **Helmet**: Headers de seguridad
- **Rate Limiting**: Protecci√≥n contra spam
- **CORS**: Control de or√≠genes permitidos
- **Input Validation**: Validaci√≥n con Joi
- **SQL Injection Protection**: Uso de par√°metros preparados
- **Normalizaci√≥n de Datos**: Evita inyecci√≥n de datos maliciosos en nombres de vistas
- **Autenticaci√≥n Centralizada**: Validaci√≥n de tokens en API Gateway
- **Validaci√≥n de Headers**: Middleware para verificar `user_id`
- **Separaci√≥n de Responsabilidades**: Microservicios sin l√≥gica de auth duplicada

## üöÄ Despliegue

### Docker

```dockerfile
FROM node:16-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
EXPOSE 3001
CMD ["npm", "start"]
```

### Variables de Producci√≥n

```bash
NODE_ENV=production
PORT=3001
DB_HOST=your-db-host
DB_PASSWORD=your-secure-password
ALLOWED_ORIGINS=https://yourdomain.com
```

### Configuraci√≥n del API Gateway

Para producci√≥n, aseg√∫rate de que el API Gateway est√© configurado correctamente:

```yaml
# Ejemplo para Kong Gateway
services:
  - name: engagement-service
    url: http://engagement-service:3001
    routes:
      - name: engagement-routes
        paths: ["/api/engagement-logs"]
        strip_path: true
        plugins:
          - name: jwt
            config:
              secret: your-production-jwt-secret
              key_claim_name: user_id
          - name: cors
            config:
              origins: ["https://yourdomain.com"]
```

### Migraci√≥n de Datos

Si tienes datos existentes con la estructura anterior:

```sql
-- 1. Crear tabla temporal
CREATE TABLE engagement_logs_temp AS SELECT * FROM engagement_logs;

-- 2. Crear tabla views_availabe
CREATE TABLE views_availabe (
  id SERIAL PRIMARY KEY,
  view_name VARCHAR(255) UNIQUE NOT NULL
);

-- 3. Insertar vistas √∫nicas
INSERT INTO views_availabe (view_name)
SELECT DISTINCT view_name FROM engagement_logs_temp;

-- 4. Actualizar engagement_logs con view_id
UPDATE engagement_logs 
SET view_id = va.id
FROM views_availabe va
WHERE engagement_logs.view_name = va.view_name;

-- 5. Eliminar columna view_name y agregar constraint
ALTER TABLE engagement_logs DROP COLUMN view_name;
ALTER TABLE engagement_logs ADD CONSTRAINT fk_view_id FOREIGN KEY (view_id) REFERENCES views_availabe(id);
```

## ü§ù Contribuci√≥n

1. Fork el proyecto
2. Crea una rama para tu feature (`git checkout -b feature/AmazingFeature`)
3. Commit tus cambios (`git commit -m 'Add some AmazingFeature'`)
4. Push a la rama (`git push origin feature/AmazingFeature`)
5. Abre un Pull Request

## üìä Caracter√≠sticas Implementadas

- ‚úÖ **Arquitectura en capas** (Model-Service-Controller)
- ‚úÖ **Base de datos normalizada** con tabla de vistas
- ‚úÖ **Validaci√≥n de datos** con Joi
- ‚úÖ **Manejo de errores** robusto
- ‚úÖ **Rate limiting** y seguridad
- ‚úÖ **Logging** y monitoreo
- ‚úÖ **Tests unitarios** completos
- ‚úÖ **Documentaci√≥n** completa
- ‚úÖ **Ejemplos de implementaci√≥n** frontend
- ‚úÖ **An√°lisis de engagement** para ML
- ‚úÖ **Gesti√≥n autom√°tica** de vistas
- ‚úÖ **√çndices optimizados** para rendimiento
- ‚úÖ **Health checks** para monitoreo
- ‚úÖ **Autenticaci√≥n centralizada** con API Gateway
- ‚úÖ **Middleware de validaci√≥n** de headers
- ‚úÖ **Integraci√≥n segura** con JWT tokens
- ‚úÖ **Tests de autenticaci√≥n** completos

## üìÑ Licencia

Este proyecto est√° bajo la Licencia MIT - ver el archivo [LICENSE](LICENSE) para detalles. 